# Dynamin Programming (DP)

## 1. DP란 무엇인가?
**DP(Dynamic Programming, 동적 계획법)**은
큰 문제를 작은 부분 문제(Subproblem)로 나누고,
그 결과를 저장하며(Memoization)
중복 계산을 제거함으로써 문제를 효율적으로 해결하는 알고리즘 기법.

요약
- **중복 계산을 줄인다.**
- **작은 문제의 답을 저장해 두었다가 재사용한다.**
- **큰 문제의 정답은 작은 문제들의 정답으로 구성된다.**

---

## 2. DP가 필요한 문제의 2가지 조건
DP가 통하는 문제는 다음 두 성질을 만족한다.

### 1) Overlapping Subproblems (겹치는 부분 문제)
같은 계산이 반복적으로 등장하는 문제.

예: 피보나치
F(10)을 구하려면 F(9), F(8) 필요 -> F(8), F(7), ... 중복 등장

### 2) Optimal Substructure (최적 부분 구조)
큰 문제의 정답이 작은 문제들의 정답 조합으로 이루어짐.

예:
`C(n, r) = C(n-1, r-1) + C(n-1, r)`

---

## 3. DP의 핵심 방식 2가지

### 방식 1) Top-Down (Memoization)
- 재귀 + 메모(캐싱)
- 필요한 순간 작은 문제를 해결한 뒤 저장.

```js
function fib(n) {
    if(n <= 1) return 1;
    if(memo[n]) return memo[n];
    return memo[n] = fib(n - 1) + fib(n - 2);
}
```

### 방식 2) Bottom-Up (Tabulation)
- 표를 아래에서부터 채워 올리는 방식.
- 재귀 사용 없음

```js
dp[0] = 0;
dp[1] = 1;

for(let i = 2; i <= n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2];
}
```

---

## 4. 대표적인 DP 예시

### 1) 피보나치 수열 (Fibonacci)
중복 계산이 수십만 번 수행됨 -> DP로 반드시 최적화.

### 2) 조합 (Combination)
파스칼의 삼각형 공식 이용
`C(n, r) = C(n-1, r-1) + C(n-1, r)`

### 3) 최장 증가 부분 수열 (LIS)

### 4) 배낭 문제 (Knapsack Problem)

### 5) 최단 경로 (일부 DP 활용)
- Floyd-Warshall
- Bellman-Ford

---

## 5. DP의 장점
| 장점 | 설명 |
| ---- | ---- |
| 성능 향상 | 중복 계산 정리 -> 시간 대폭 절약 |
| 구현 단순화 | 분할 정복과 달리 테이블 기반으로 명확 |
| 안정성 | 재귀 없이 구현하면 스택오버플로우 위험 없음 |

---

## 6. DP로 자주 쓰는 패턴

### 1) 1차원 DP
- 피보나치
- 계단 오르기
- 부분합

### 2) 2차원 DP
- 조합
- 배낭 문제
- 문자열 편집 거리

### 3) 그리디와 혼합
- 최적해가 DP인지 Greedy인지 판단하는 능력 중요.

---

## 7. DP를 푸는 사고 방식 (문제 접근 방법)

1. 문제를 작은 조각으로 나눌 수 있는가?
2. 작은 문제들의 관계식을 정의할 수 있는가? (점화식)
3. 초기값(Base Case)은 무엇인가?
4. 테이블(dp 배열)의 크기는 어떻게 되는가?
5. Top-down 또는 Bottom-up 중 어떤 방식이 적절한가?