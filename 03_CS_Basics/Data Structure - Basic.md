# 자료구조(Data Structure) 이론 정리 노트

> 목표
- “무슨 자료구조를 언제 쓰는지”를 판단할 수 있게 정리
- 시간복잡도(평균/최악) 기준으로 선택 근거 만들기
- 코테 문제를 풀 때 바로 떠올릴 수 있는 형태로 요약

---

## 1. 자료구조란?

자료구조는 데이터를 **저장**하고, 데이터를 대상으로 하는 연산(삽입/삭제/탐색/정렬/조회)을 **효율적으로** 하기 위한 방법이다.

- 데이터의 “형태(구조)”가 연산의 성능을 결정한다.
- 따라서 자료구조 선택은 곧 **시간복잡도와 구현 난이도**의 선택이다.

---

## 2. Big-O(시간복잡도) 빠른 기준

- O(1): 입력 크기와 무관하게 일정
- O(log n): 트리/이진탐색에서 자주 등장
- O(n): 한 번 훑기
- O(n log n): 정렬의 대표
- O(n^2): 이중 반복(대개 n이 작을 때만 허용)

---

## 3. 스택(Stack)

### 3.1 정의
- **LIFO(Last-In First-Out)**: 마지막에 넣은 것이 먼저 나온다.
- 대표 연산: push(삽입), pop(삭제), top/peek(조회), size, empty

### 3.2 시간복잡도(일반적인 구현 기준)
- push: O(1)
- pop: O(1)
- top: O(1)
- size/empty: O(1)

### 3.3 활용 패턴(코테에서 “스택 냄새” 나는 경우)
- 괄호 검사 `()[]{}` (올바른 괄호)
- “이전 상태로 되돌리기”(undo), 브라우저 뒤로가기
- DFS(재귀를 스택으로 바꾸기)
- 단조 스택(Monotonic Stack): “다음 큰 수 / 다음 작은 수” 류

---

## 4. 큐(Queue)

### 4.1 정의
- **FIFO(First-In First-Out)**: 먼저 넣은 것이 먼저 나온다.
- 대표 연산: enqueue(삽입), dequeue(삭제), front, size, empty

### 4.2 시간복잡도
- 배열로 단순 구현하면 shift 때문에 O(n) 될 수 있음
- 보통 “원형 큐” or “투 포인터”로 O(1)에 가깝게 처리

### 4.3 활용
- BFS(최단 거리/레벨 탐색)
- 작업 대기열(프린터, 이벤트 처리)

---

## 5. 덱(Deque)

### 5.1 정의
- 양쪽에서 삽입/삭제 가능한 큐
- push_front, push_back, pop_front, pop_back

### 5.2 활용
- 슬라이딩 윈도우 최적화
- 0-1 BFS(가중치 0/1 그래프)

---

## 6. 배열(Array) vs 연결 리스트(Linked List)

### 6.1 배열
- 연속된 메모리, 인덱스 접근이 빠름
- 장점: 임의 접근 O(1)
- 단점: 중간 삽입/삭제 O(n)

### 6.2 연결 리스트
- 노드가 포인터로 연결됨
- 장점: (노드를 알고 있을 때) 삽입/삭제 O(1)
- 단점: 임의 접근 O(n), 캐시 효율 낮음

> 코테에서는 연결 리스트를 직접 구현하는 경우가 배열보다 적지만,
> “삽입/삭제가 매우 잦고 중간에서 일어난다”면 후보가 된다.

---

## 7. 해시(Hash) / Map / Set

### 7.1 정의
- 키(key)로 값을 빠르게 찾는 자료구조
- 평균적으로 탐색/삽입/삭제가 O(1)에 가깝다.

### 7.2 시간복잡도(일반)
- 평균: O(1)
- 최악: O(n) (충돌이 심하거나 공격적 입력 등)

### 7.3 활용
- 빈도수 카운팅(문자/숫자/단어)
- 중복 제거(Set)
- 빠른 존재 여부 체크(visited)

---

## 8. 힙(Heap) / 우선순위 큐(Priority Queue)

### 8.1 정의
- “가장 큰 값/가장 작은 값”을 빠르게 꺼내는 구조
- 최소 힙/최대 힙

### 8.2 시간복잡도
- 삽입: O(log n)
- 최솟값/최댓값 조회: O(1)
- 삭제(pop): O(log n)

### 8.3 활용
- Dijkstra(최단거리)
- 상위 K개 유지, 스트리밍 데이터에서 최소/최대 추적

---

## 9. 트리(Tree)

### 9.1 정의
- 계층 구조. 부모-자식 관계.
- 이진 트리, BST, AVL, Red-Black 등 변형이 많다.

### 9.2 핵심
- “탐색을 log n으로 만들고 싶다” → 균형 트리가 중요
- 코테에서는 “트리 순회”와 “트리 DP” 형태로 많이 등장

---

## 10. 그래프(Graph)

### 10.1 정의
- 정점(V)과 간선(E)
- 방향/무방향, 가중치/무가중치

### 10.2 표현 방식
- 인접 리스트: 보통 코테 표준 (공간 효율)
- 인접 행렬: 정점 수가 작을 때 유리

### 10.3 탐색
- DFS: 깊이 우선
- BFS: 너비 우선 (최단 거리 느낌이 강함)

---

## 11. “무슨 자료구조를 쓰면 되지?” 빠른 선택 규칙

- 마지막에 넣은 걸 먼저 꺼내야 한다 → 스택
- 먼저 넣은 걸 먼저 처리해야 한다 → 큐
- 양쪽에서 넣고 빼야 한다 → 덱
- 빠른 존재 여부/카운팅/키-값 저장 → 해시(Map/Set)
- 최솟값/최댓값을 계속 꺼내야 한다 → 힙(우선순위 큐)
- 계층/부모-자식/구간 구조 → 트리
- 관계/연결/최단경로/네트워크 → 그래프

---

## 12. (학습 메모) 내가 자주 헷갈리는 포인트

- 배열로 큐 구현 시 shift가 O(n)이라 느려질 수 있음
- 해시는 평균 O(1)이지만 최악이 O(n) 가능
- “정렬해서 상위 K개” vs “힙으로 상위 K개 유지” 판단 필요
- BFS는 큐, DFS는 스택/재귀

---
