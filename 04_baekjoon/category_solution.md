# 코딩 테스트 대비용 유형별 풀이 방법

## 1, 투 포인터 & 슬라이딩 윈도우

### 1) `for`문만 쓰는 슬라이딩 윈도우 (고정 길이)

#### 언제 쓰는 것인가!
- 윈도우 길이 K가 고정
- "연속한 K개의 합/최댓값/최솟값/개수" 같은 문제
- 예: 백준 2559, 12847, 21921

#### 패턴
- 처음 K개 합을 만들고
- i를 K부터 N-1까지 돌리면서 `-빠진 값 + 들어온 값`

```js
let sum = 0;
for(let i = 0; i < K; i++) sum += arr[i]

let best = sum;
for(let i = K; i < N; i++){
    sum = sum - arr[i - K] + arr[i];

    if(sum > best) {
        best = sum;
    }
}
```

- 특징: right = i, left = i-K 라서 변수 두 개를 굳이 안 둠.
- 가장 깔끔하고 실수 적음

### 2) `left` 하나만 쓰는 슬라이딩 윈도우 (고정 길이의 다른 표현)

#### 언제 쓰는 것인가!
- 위 1) 과 같은 고정 길이인데, `left`를 명시하고 싶을 때
- 또는 queue/빈도표 같은 상태관리가 같이 들어가서 "구간 시작점"을 명확히 두고 싶을 때

```js
let left = 0;
let sum = 0;

// right가 for문의 i로 숨어있음.
for(let i = 0; i < N; i++){
    sum += arr[i];

    if(i - left + 1 === K) {
        sum -= arr[left];
        left++;
    }
}
```

- 특징: right는 `for(i=...)`로 존재하지만, "left만 따로 변수"로 둠.
- K 고정인데도 "윈도우를 유지한다" 감각이 더 잘 보임
- 21921번처럼 max와 count까지 다룰 때도 이 형태로 많이 함.

### 3) `left + right` 둘 다 쓰는 투 포인터 (가변 길이)

#### 언제 쓰는 것인가!
- 윈도우 길이가 고정이 아님
- 조건에 따라 늘렸다 줄였다 해야 함.
- 예: 2003(연속합), 1806(부분합), "합이 M 이상이면 줄이고, 부족하면 늘리는" 류
- 보통 배열 원소가 양수일 때 깔끔하게 성립

#### 패턴
```js
let left = 0, right = 0;
let sum = 0;
let count = 0;

while(true) {
    if(sum >= M) {
        if(sum === M) count++;
        sum -= arr[left++];
    } else {
        if(right === N) break;
        sum += arr[right++];
    }
}
```

- 특징: left/right 둘 다 조건에 의해 움직임.
- "고정 길이"가 아니라서 슬라이딩 윈도우(고정 K) 템플릿을 쓰면 꼬임

### 4) 그럼 "어떻게 나눠서" 쓰면 되는가!

#### Q1. 구간 길이가 고정이야?
- 고정이면 -> 슬라이딩 윈도우 (1번 or 2번)
- 고정이 아니면 -> 투 포인터(가변)

#### Q2. 조건이 "sum이 커지면 줄이고, 작으면 늘리고" 처럼 단조로워?
- 단조롭다(주로 양수 배열) -> 투 포인터 잘 됨
- 단조롭지 않다(음수/0 섞임) -> 투 포인터가 깨질 수 있음
-> 이 땐 보통 누적합+해시, 정렬+투포인터, 다른 접근 필요